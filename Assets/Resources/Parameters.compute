#define NUM_THREADS 1024
#define MAX_PARTICLES_PER_VOXEL 8
#define POW3(x) ((x)*(x)*(x))
#define POW2(x) ((x)*(x))

static const float PI = 3.14159265358979323846264338327950288;
static const float Epsilon = 1e-5;

struct ShaderParameters
{
    uint _MaxL;
    uint _TimeStep;
};

#pragma enable_d3d11_debug_symbols

// Buffers
StructuredBuffer<float2> _PositionBuffer;
StructuredBuffer<float2> _VelocityBuffer;
RWStructuredBuffer<float> _WaterDepthBuffer;
RWStructuredBuffer<float> _SmoothingLengthBuffer;
StructuredBuffer<uint> _Bucket;
RWStructuredBuffer<ShaderParameters> _ShaderParametersBuffer;

// Parameters
float2 _DomainMax;
float2 _DomainMin;
float _TexturePixelSize;
float _MetersPerPixel;
float _ParticleVolume;
float _Gravity;
uint _BucketResolution;
uint _N;

float W(float rIJ, float l)
{
    float q = rIJ / l;
    if (q > 2.0 || q < 0.0) return 0.0;

    float alpha = 15.0 / (7.0 * PI * POW2(l));

    return alpha * (q < 1 ? 2.0 / 3.0 - POW2(q) + 0.5 * POW3(q) : POW3(2 - q) / 6.0);
}

#pragma kernel CSMain

[numthreads(NUM_THREADS, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Check if we're within texture bounds
    if (id.x >= _N)
        return;

    uint i = id.x;

    float h = 0.0;

    float2 pos = _PositionBuffer[i];
    int2 index3dI = int2((pos - _DomainMin) / (_DomainMax - _DomainMin) * (_BucketResolution - 1));
    uint index1d = (index3dI.x + index3dI.y * _BucketResolution) * MAX_PARTICLES_PER_VOXEL;

    for (int x_offset = -1; x_offset <= 1; x_offset++)
    for (int y_offset = -1; y_offset <= 1; y_offset++){
        uint2 index3dJ = index3dI + int2(x_offset, y_offset);
        if(all(index3dJ >= 0) && all(index3dJ < _BucketResolution))
        {
            uint bktJ = (index3dJ.x + index3dJ.y * _BucketResolution) * MAX_PARTICLES_PER_VOXEL;
            for (uint j2 = 0; j2 < MAX_PARTICLES_PER_VOXEL; j2++){
                uint j = _Bucket[bktJ + j2];
                if (j == _N) break;

                float rIJ = distance(pos, _PositionBuffer[j]) / _TexturePixelSize * _MetersPerPixel;

                h += _ParticleVolume * W(rIJ, 
                _SmoothingLengthBuffer[i]);
            }
        }
    }

    if (h <= Epsilon) return;

    if (_WaterDepthBuffer[i] == -1) _WaterDepthBuffer[i] = h;

    if (_WaterDepthBuffer[i] > Epsilon)
    {
        _SmoothingLengthBuffer[i] *= sqrt(_WaterDepthBuffer[i] / h);

        uint compareValue = _ShaderParametersBuffer[0]._MaxL;
        uint outValue = 0;

        uint i_val = asuint(max(_SmoothingLengthBuffer[i], asfloat(_ShaderParametersBuffer[0]._MaxL)));

        [allow_uav_condition]
        while (true)
        {
            InterlockedCompareExchange(_ShaderParametersBuffer[0]._MaxL, compareValue, i_val, outValue);
            if (outValue == compareValue)
                break;

            compareValue = outValue;
            i_val = asuint(max(_SmoothingLengthBuffer[i], asfloat(outValue)));
        }
    }
    
    _WaterDepthBuffer[i] = h;

    if (_WaterDepthBuffer[i] <= Epsilon || _SmoothingLengthBuffer[i] <= Epsilon) return;

    float newTimeStep = _SmoothingLengthBuffer[i] / (sqrt(_Gravity * _WaterDepthBuffer[i]) + length(_VelocityBuffer[i]));

    uint compareValue = _ShaderParametersBuffer[0]._TimeStep;
    uint outValue = 0;

    uint i_val = asuint(min(newTimeStep, asfloat(_ShaderParametersBuffer[0]._TimeStep)));

    [allow_uav_condition]
    while (true)
    {
        InterlockedCompareExchange(_ShaderParametersBuffer[0]._TimeStep, compareValue, i_val, outValue);
        if (outValue == compareValue)
            break;

        compareValue = outValue;
        i_val = asuint(min(newTimeStep, asfloat(outValue)));
    }
}
